"""
AI Agent Service using OpenAI GPT-4

This service provides intelligent planning and scheduling assistance.
It can work in two modes:
1. AI Mode (with OpenAI API key) - Full GPT-4 capabilities
2. Fallback Mode (without API key) - Rule-based responses
"""

import os
import json
from typing import Dict, Optional, List
from datetime import datetime, timedelta
from openai import OpenAI


class AIAgent:
    """
    AI Agent for production planning and scheduling
    
    Features:
    - Natural language processing
    - Context-aware responses
    - Weather-based recommendations
    - Employee availability checking
    - Task creation assistance
    - Fallback mode when no API key available
    """
    
    def __init__(self):
        """Initialize AI Agent with optional OpenAI integration"""
        api_key = os.getenv("OPENAI_API_KEY")
        self.use_ai = bool(api_key)
        
        if self.use_ai:
            try:
                self.client = OpenAI(api_key=api_key)
                print("‚úÖ AI Agent initialized with OpenAI GPT-4")
            except Exception as e:
                print(f"‚ö†Ô∏è OpenAI initialization failed: {e}")
                self.use_ai = False
                self.client = None
        else:
            self.client = None
            print("‚ö†Ô∏è Running in FALLBACK mode - no AI (OpenAI API key not set)")
        
        self.system_prompt = """Si inteligentn√Ω asistent pre pl√°novanie v√Ωroby a in≈°tal√°ci√≠.
Tvoja √∫loha je pom√°ha≈• s:
- Vytv√°ranie pl√°nov √∫loh
- Priradenie zamestnancov
- Kontrola dostupnosti
- Odpor√∫ƒçania na z√°klade poƒçasia
- Optimaliz√°cia rozvrhu

V≈ædy odpovedaj po slovensky, struƒçne a prakticky.
Ak potrebuje≈° vykona≈• akciu (napr. vytvori≈• √∫lohu), vr√°≈• action v JSON form√°te.
"""
    
    def chat(
        self,
        message: str,
        context: Optional[Dict] = None
    ) -> Dict:
        """
        Process user message and return response
        
        Args:
            message: User's message
            context: Optional context (weather, employees, tasks, etc.)
        
        Returns:
            Dict with response, suggestions, and optional action
        """
        if not self.use_ai:
            return self._fallback_chat(message, context)
        
        try:
            # Prepare context for GPT
            context_str = self._format_context(context or {})
            
            # Prepare messages
            messages = [
                {"role": "system", "content": self.system_prompt},
                {"role": "user", "content": f"{message}\n\nKontext:\n{context_str}"}
            ]
            
            # Call OpenAI API
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=messages,
                temperature=0.7,
                max_tokens=500
            )
            
            ai_response = response.choices[0].message.content
            
            # Parse response
            result = {
                "response": ai_response,
                "suggestions": self._extract_suggestions(ai_response, context),
                "action_type": None,
                "action_params": None
            }
            
            # Detect if action should be taken
            action = self._detect_action(message, ai_response, context)
            if action:
                result["action_type"] = action["type"]
                result["action_params"] = action["params"]
            
            return result
            
        except Exception as e:
            print(f"‚ùå OpenAI API Error: {e}")
            # Fallback to rule-based
            return self._fallback_chat(message, context)
    
    def _fallback_chat(self, message: str, context: Optional[Dict] = None) -> Dict:
        """
        Fallback chat when AI is not available
        Uses rule-based responses
        """
        message_lower = message.lower()
        context = context or {}
        
        # Weather queries
        if any(word in message_lower for word in ['poƒçasie', 'weather', 'pr≈°√≠', 'slnko', 'd√°≈æƒè']):
            return self._handle_weather_query(context)
        
        # Employee queries
        if any(word in message_lower for word in ['zamestnanc', 'employee', 'pracovn√≠k', 'dostupn']):
            return self._handle_employee_query(message_lower, context)
        
        # Task creation
        if any(word in message_lower for word in ['vytvor', 'pridaj', 'napl√°nuj', 'create', 'add']):
            return self._handle_task_creation(message, context)
        
        # Planning queries
        if any(word in message_lower for word in ['pl√°n', 'rozvrh', 'schedule', 'kedy']):
            return self._handle_planning_query(context)
        
        # Greeting
        if any(word in message_lower for word in ['ahoj', 'hello', 'dobr√Ω', 'hi', 'hey']):
            return {
                "response": "Ahoj! Som v√°≈° pl√°novac√≠ asistent. M√¥≈æem v√°m pom√¥c≈• s:\n"
                           "‚Ä¢ Pl√°novan√≠m √∫loh\n"
                           "‚Ä¢ Priraden√≠m zamestnancov\n"
                           "‚Ä¢ Kontrolou poƒçasia\n"
                           "‚Ä¢ Odpor√∫ƒçaniami na optimaliz√°ciu\n\n"
                           "ƒåo potrebujete?",
                "suggestions": [
                    "Ak√© je dnes poƒçasie?",
                    "Kto je dnes dostupn√Ω?",
                    "Vytvor nov√∫ √∫lohu"
                ],
                "action_type": None,
                "action_params": None
            }
        
        # Default response
        return {
            "response": "Prep√°ƒçte, nerozumiem presne ƒço potrebujete. "
                       "M√¥≈æete sa op√Ωta≈• na poƒçasie, dostupnos≈• zamestnancov, "
                       "alebo ma po≈æiada≈• o vytvorenie √∫lohy.",
            "suggestions": [
                "Ak√© je poƒçasie?",
                "Kto je dostupn√Ω zajtra?",
                "Vytvor in≈°tal√°ciu na bud√∫ci t√Ω≈æde≈à"
            ],
            "action_type": None,
            "action_params": None
        }
    
    def _handle_weather_query(self, context: Dict) -> Dict:
        """Handle weather-related queries"""
        weather = context.get('weather', {})
        
        if not weather:
            return {
                "response": "Nem√°m inform√°cie o poƒças√≠. Skontrolujte nastavenie Weather API.",
                "suggestions": ["Sk√∫si≈• nesk√¥r"],
                "action_type": None,
                "action_params": None
            }
        
        temp = weather.get('temperature', 'N/A')
        desc = weather.get('description', 'nezn√°me')
        recommendation = weather.get('recommendation', 'unknown')
        
        if recommendation == 'installation':
            msg = f"üå§Ô∏è Poƒçasie je vhodn√© pre in≈°tal√°cie!\n" \
                  f"Teplota: {temp}¬∞C\n" \
                  f"Podmienky: {desc}\n\n" \
                  f"Odpor√∫ƒçam napl√°nova≈• vonkaj≈°ie pr√°ce."
        elif recommendation == 'production':
            msg = f"üåßÔ∏è Poƒçasie nie je ide√°lne pre in≈°tal√°cie.\n" \
                  f"Teplota: {temp}¬∞C\n" \
                  f"Podmienky: {desc}\n\n" \
                  f"Odpor√∫ƒçam zamera≈• sa na v√Ωrobu v dielni."
        else:
            msg = f"üìä Aktu√°lne poƒçasie:\n" \
                  f"Teplota: {temp}¬∞C\n" \
                  f"Podmienky: {desc}"
        
        return {
            "response": msg,
            "suggestions": [
                "Kto je dostupn√Ω pre in≈°tal√°cie?" if recommendation == 'installation' else "Kto m√¥≈æe pracova≈• na v√Ωrobe?",
                "Napl√°nuj √∫lohu"
            ],
            "action_type": None,
            "action_params": None
        }
    
    def _handle_employee_query(self, message: str, context: Dict) -> Dict:
        """Handle employee-related queries"""
        employees = context.get('employees', [])
        
        if not employees:
            return {
                "response": "Nena≈°iel som ≈æiadnych zamestnancov v syst√©me. Pridajte najprv zamestnancov.",
                "suggestions": ["Prida≈• zamestnanca"],
                "action_type": None,
                "action_params": None
            }
        
        # Count by type
        installers = [e for e in employees if e.get('employee_type') in ['installer', 'both']]
        producers = [e for e in employees if e.get('employee_type') in ['producer', 'both']]
        
        msg = f"üë• M√°te celkom {len(employees)} zamestnancov:\n\n"
        msg += f"üîß In≈°talat√©ri: {len(installers)}\n"
        msg += f"üè≠ V√Ωrobcovia: {len(producers)}\n\n"
        
        if 'dostupn' in message or 'available' in message:
            msg += "Pre kontrolu dostupnosti konkr√©tneho d≈àa uveƒète d√°tum."
        
        return {
            "response": msg,
            "suggestions": [
                "Kto je dostupn√Ω zajtra?",
                "Vytvor √∫lohu"
            ],
            "action_type": None,
            "action_params": None
        }
    
    def _handle_task_creation(self, message: str, context: Dict) -> Dict:
        """Handle task creation requests"""
        message_lower = message.lower()
        
        # Detect task type
        task_type = 'production'
        if any(word in message_lower for word in ['in≈°tal√°c', 'install', 'mont√°≈æ']):
            task_type = 'installation'
        
        return {
            "response": f"M√¥≈æem vytvori≈• nov√∫ √∫lohu typu '{task_type}'. "
                       f"Pros√≠m ≈°pecifikujte:\n"
                       f"‚Ä¢ N√°zov √∫lohy\n"
                       f"‚Ä¢ D√°tum a ƒças\n"
                       f"‚Ä¢ Trvanie (hodiny)\n"
                       f"‚Ä¢ Popis",
            "suggestions": [
                f"Vytvor {task_type} na zajtra o 9:00",
                "Zru≈°"
            ],
            "action_type": "request_task_details",
            "action_params": {"type": task_type}
        }
    
    def _handle_planning_query(self, context: Dict) -> Dict:
        """Handle planning and scheduling queries"""
        tasks = context.get('tasks', [])
        weather = context.get('weather', {})
        
        msg = f"üìÖ Pl√°novanie:\n\n"
        
        if tasks:
            msg += f"M√°te {len(tasks)} napl√°novan√Ωch √∫loh v najbli≈æ≈°√≠ch 7 d≈àoch.\n\n"
        else:
            msg += "Nem√°te ≈æiadne napl√°novan√© √∫lohy.\n\n"
        
        # Weather-based recommendation
        if weather:
            rec = weather.get('recommendation', 'unknown')
            if rec == 'installation':
                msg += "üí° Odpor√∫ƒçanie: Poƒçasie je vhodn√© pre in≈°tal√°cie."
            elif rec == 'production':
                msg += "üí° Odpor√∫ƒçanie: Zamerajte sa na v√Ωrobu v dielni."
        
        return {
            "response": msg,
            "suggestions": [
                "Vytvor nov√∫ √∫lohu",
                "Zobraz zamestnancov",
                "Ak√© je poƒçasie?"
            ],
            "action_type": None,
            "action_params": None
        }
    
    def _format_context(self, context: Dict) -> str:
        """Format context dictionary for GPT"""
        parts = []
        
        if 'weather' in context:
            weather = context['weather']
            parts.append(f"Poƒçasie: {weather.get('temperature')}¬∞C, {weather.get('description')}")
        
        if 'employees' in context:
            employees = context['employees']
            parts.append(f"Zamestnanci: {len(employees)} akt√≠vnych")
        
        if 'tasks' in context:
            tasks = context['tasks']
            parts.append(f"√ölohy: {len(tasks)} napl√°novan√Ωch")
        
        return "\n".join(parts) if parts else "≈Ωiadny kontext"
    
    def _extract_suggestions(self, response: str, context: Dict) -> List[str]:
        """Extract relevant suggestions based on response and context"""
        suggestions = []
        
        response_lower = response.lower()
        
        if 'poƒçasie' in response_lower:
            suggestions.append("Ak√© je poƒçasie zajtra?")
        
        if 'zamestnanc' in response_lower:
            suggestions.append("Kto je dostupn√Ω?")
        
        if '√∫loha' in response_lower or 'task' in response_lower:
            suggestions.append("Vytvor nov√∫ √∫lohu")
        
        # Default suggestions
        if not suggestions:
            suggestions = [
                "Ak√© je poƒçasie?",
                "Kto je dostupn√Ω?",
                "Vytvor √∫lohu"
            ]
        
        return suggestions[:3]  # Max 3 suggestions
    
    def _detect_action(self, message: str, response: str, context: Dict) -> Optional[Dict]:
        """Detect if an action should be taken based on the conversation"""
        message_lower = message.lower()
        response_lower = response.lower()
        
        # Task creation
        if any(word in message_lower for word in ['vytvor', 'pridaj', 'napl√°nuj', 'create']):
            if any(word in message_lower for word in ['√∫loha', 'task', 'in≈°tal√°c', 'v√Ωrob']):
                return {
                    "type": "create_task",
                    "params": self._extract_task_params(message)
                }
        
        return None
    
    def _extract_task_params(self, message: str) -> Dict:
        """Extract task parameters from message"""
        message_lower = message.lower()
        
        # Detect task type
        task_type = 'production'
        if any(word in message_lower for word in ['in≈°tal√°c', 'install', 'mont√°≈æ']):
            task_type = 'installation'
        
        # Try to detect date
        today = datetime.now()
        start_time = today
        
        if 'zajtra' in message_lower or 'tomorrow' in message_lower:
            start_time = today + timedelta(days=1)
        elif 'dnes' in message_lower or 'today' in message_lower:
            start_time = today
        
        # Default duration
        duration = 4.0  # 4 hours
        
        return {
            "task_type": task_type,
            "start_time": start_time.isoformat(),
            "duration_hours": duration,
            "title": f"Nov√° {task_type} √∫loha",
            "description": message
        }


# Singleton instance
_ai_agent_instance = None


def get_ai_agent() -> AIAgent:
    """Get or create AI Agent instance"""
    global _ai_agent_instance
    if _ai_agent_instance is None:
        _ai_agent_instance = AIAgent()
    return _ai_agent_instance
